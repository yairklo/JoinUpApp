generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String          @id
  email          String?         @unique
  name           String?
  imageUrl       String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  birthDate      DateTime?
  city           String?
  phone          String?
  reputation     Int             @default(50)
  favoriteFields FavoriteField[]
  requestsRecv   FriendRequest[] @relation("Recv")
  requestsSent   FriendRequest[] @relation("Sent")
  friendshipsA   Friendship[]    @relation("A")
  friendshipsB   Friendship[]    @relation("B")
  organizedGames Game[]          @relation("OrganizerGames")
  participations Participation[]
  gameRoles      GameRole[]
  positions      UserPosition[]
  sports         UserSport[]
  seriesSubscriptions SeriesParticipant[]
  chatParticipations ChatParticipant[]
  messages       Message[]
  
  // Notification System
  notifications  Notification[]  @relation("UserNotifications")
  devices        UserDevice[]    @relation("UserDevices")
  notificationSettings UserNotificationSettings? @relation("UserNotificationSettings")
}

model Field {
  id           String          @id @default(cuid())
  name         String
  location     String
  description  String?
  price        Int             @default(0)
  rating       Float           @default(0)
  image        String?
  available    Boolean         @default(true)

  type         FieldType
  supportedSports SportType[] @default([SOCCER])
  lat          Float?
  lng          Float?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  city         String?
  email        String?
  featuresJson Json?
  neighborhood String?
  phone        String?
  photos       String[]
  street       String?
  streetNumber String?
  favorites    FavoriteField[]
  games        Game[]
}

model Game {
  id           String          @id @default(cuid())
  title        String?
  fieldId      String
  /// Optional reference to a recurring series
  seriesId     String?
  start        DateTime
  duration     Int             @default(1)
  maxPlayers   Int
  teamSize     Int?
  price        Int?
  isOpenToJoin Boolean         @default(true)
  // Visible only to organizer's friends and participants when true
  isFriendsOnly Boolean        @default(false)
  // When set, game becomes public automatically at this time
  friendsOnlyUntil DateTime?
  // Allow signups beyond capacity and finalize participants by lottery
  lotteryEnabled    Boolean   @default(false)
  // Exact datetime when the lottery should run (when enabled)
  lotteryAt        DateTime?
  // Include organizer in the lottery draw instead of confirming them immediately
  organizerInLottery Boolean  @default(false)
  // Set when the lottery has executed
  lotteryExecutedAt DateTime?
  description  String?
  // Optional custom location for games not tied to a mapped field
  customLat    Float?
  customLng    Float?
  customLocation String?
  organizerId  String
  sport        SportType       @default(SOCCER)
  status       GameStatus      @default(OPEN)
  registrationOpensAt DateTime?
  reminderSent Boolean         @default(false) // Track if 1-hour reminder was sent
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  field        Field           @relation(fields: [fieldId], references: [id])
  organizer    User            @relation("OrganizerGames", fields: [organizerId], references: [id])
  /// Parent series relation (optional)
  series       GameSeries?     @relation(fields: [seriesId], references: [id])
  participants Participation[]
  roles        GameRole[]
  teams        Team[]
}

enum GameStatus {
  OPEN
  COMPLETED
  CANCELLED
}

model Participation {
  id        String   @id @default(cuid())
  gameId    String
  userId    String
  teamId    String?
  status    ParticipationStatus @default(CONFIRMED)
  createdAt DateTime @default(now())
  game      Game     @relation(fields: [gameId], references: [id])
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  team      Team?    @relation(fields: [teamId], references: [id])

  @@unique([gameId, userId])
}

// ... (Fields, Game, Participation models remain unchanged)

model ChatRoom {
  id           String            @id @default(cuid())
  type         String            @default("PRIVATE") // "PRIVATE" or "GROUP"
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  messages     Message[]
  participants ChatParticipant[]
}

model ChatParticipant {
  id        String   @id @default(cuid())
  userId    String
  chatId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  chat      ChatRoom @relation(fields: [chatId], references: [id], onDelete: Cascade)
  joinedAt  DateTime @default(now())
  lastReadAt DateTime?
  
  @@unique([userId, chatId])
}

enum MessageStatus {
  sent
  delivered
  read
  rejected
}

model Message {
  id        String   @id @default(cuid())
  chatRoomId String
  chatRoom   ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  text      String
  status    MessageStatus @default(sent)
  createdAt DateTime @default(now())
  isEdited  Boolean  @default(false)
  isDeleted Boolean  @default(false)
  // New: Reply Relation
  replyToId String?
  replyTo   Message? @relation("ReplyTo", fields: [replyToId], references: [id])
  replies   Message[] @relation("ReplyTo")

  // New: Reactions Relation
  reactions Reaction[]
}

model Reaction {
  id        String   @id @default(cuid())
  emoji     String
  userId    String
  messageId String
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, messageId, emoji])
}

model FavoriteField {
  id      String @id @default(cuid())
  userId  String
  fieldId String
  field   Field  @relation(fields: [fieldId], references: [id])
  user    User   @relation(fields: [userId], references: [id])

  @@unique([userId, fieldId])
}

model Friendship {
  id        String   @id @default(cuid())
  userAId   String
  userBId   String
  createdAt DateTime @default(now())
  userA     User     @relation("A", fields: [userAId], references: [id])
  userB     User     @relation("B", fields: [userBId], references: [id])

  @@unique([userAId, userBId])
}

model FriendRequest {
  id          String              @id @default(cuid())
  requesterId String
  receiverId  String
  status      FriendRequestStatus @default(PENDING)
  createdAt   DateTime            @default(now())
  receiver    User                @relation("Recv", fields: [receiverId], references: [id])
  requester   User                @relation("Sent", fields: [requesterId], references: [id])

  @@unique([requesterId, receiverId])
}

model Sport {
  id        String      @id @default(cuid())
  name      String      @unique
  positions Position[]
  users     UserSport[]
}

model Position {
  id      String         @id @default(cuid())
  name    String
  sportId String
  sport   Sport          @relation(fields: [sportId], references: [id])
  users   UserPosition[]

  @@unique([sportId, name])
}

model UserSport {
  id      String @id @default(cuid())
  userId  String
  sportId String
  sport   Sport  @relation(fields: [sportId], references: [id])
  user    User   @relation(fields: [userId], references: [id])
  positionDescription String?

  @@unique([userId, sportId])
}

model UserPosition {
  id         String   @id @default(cuid())
  userId     String
  positionId String
  position   Position @relation(fields: [positionId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@unique([userId, positionId])
}

model GameRole {
  id        String        @id @default(cuid())
  gameId    String
  userId    String
  role      GameRoleType  @default(MANAGER)
  createdAt DateTime      @default(now())
  game      Game          @relation(fields: [gameId], references: [id])
  user      User          @relation(fields: [userId], references: [id])

  @@unique([gameId, userId])
}

model Team {
  id        String   @id @default(cuid())
  gameId    String
  name      String
  color     String   // hex color
  createdAt DateTime @default(now())
  game      Game     @relation(fields: [gameId], references: [id])
  players   Participation[]

  @@index([gameId])
}

enum FieldType {
  OPEN
  CLOSED
}

enum FriendRequestStatus {
  PENDING
  DECLINED
}

enum ParticipationStatus {
  WAITLISTED
  CONFIRMED
  CANCELLED
  NOT_SELECTED
}

enum GameRoleType {
  ORGANIZER
  MANAGER
  MODERATOR
}

model GameSeries {
  id             String   @id @default(cuid())
  title          String?
  organizerId    String
  fieldId        String?
  fieldName      String
  fieldLocation  String
  price          Int      @default(0)
  maxPlayers     Int
  /// 0-6 (Sunday=0 per JS Date.getDay()) - only for WEEKLY
  dayOfWeek      Int?
  /// "HH:MM"
  time           String
  /// hours (can be fractional)
  duration       Float
  isActive       Boolean  @default(true)
  sport          SportType @default(SOCCER)
  createdAt      DateTime @default(now())
  /// Recurrence type: weekly auto vs. custom dates
  type           RecurrenceType @default(WEEKLY)
  autoOpenRegistrationHours Float?

  games          Game[]
  subscribers    SeriesParticipant[]
}

model SeriesParticipant {
  id         String   @id @default(cuid())
  seriesId   String
  userId     String
  createdAt  DateTime @default(now())

  series     GameSeries @relation(fields: [seriesId], references: [id])
  user       User       @relation(fields: [userId], references: [id])

  @@unique([seriesId, userId])
}

enum RecurrenceType {
  WEEKLY
  CUSTOM
}

enum SportType {
  SOCCER
  BASKETBALL
  TENNIS
}

model FlaggedMessage {
  id            String   @id @default(cuid())
  messageId     String?
  content       String
  userId        String
  status        String   @default("PENDING_RETRY") // PENDING_RETRY, RESOLVED
  resolution    String?  // AUTO_APPROVED, AUTO_REJECTED
  retryCount    Int      @default(0)
  failureReason String?
  aiTriggers    Json?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

// ============================================
// NOTIFICATION SYSTEM
// ============================================

enum NotificationType {
  FRIEND_REQUEST
  FRIEND_ACCEPTED
  NEW_MESSAGE
  GAME_REMINDER
  GAME_CANCELLED
  GAME_UPDATED
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  body      String
  data      Json?            // Metadata: gameId, friendRequestId, chatId, link, etc.
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())
  
  user      User             @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, createdAt(sort: Desc)]) // Fast retrieval of recent notifications
  @@index([userId, read])                   // Fast counting of unread notifications
  @@index([createdAt])                      // For cleanup worker (TTL)
}

model UserDevice {
  id         String   @id @default(cuid())
  userId     String
  fcmToken   String   @unique
  deviceType String?  // "ios", "android", "web"
  deviceName String?  // User-friendly name
  lastUsed   DateTime @default(now())
  createdAt  DateTime @default(now())
  
  user       User     @relation("UserDevices", fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([fcmToken])
}

model UserNotificationSettings {
  id                    String  @id @default(cuid())
  userId                String  @unique
  pushEnabled           Boolean @default(true)
  friendRequestsEnabled Boolean @default(true)
  messagesEnabled       Boolean @default(true)
  gameRemindersEnabled  Boolean @default(true)
  
  user                  User    @relation("UserNotificationSettings", fields: [userId], references: [id], onDelete: Cascade)
}
