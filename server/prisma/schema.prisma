generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String          @id
  email          String?         @unique
  name           String?
  imageUrl       String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  birthYear      Int?
  city           String?
  phone          String?
  favoriteFields FavoriteField[]
  requestsRecv   FriendRequest[] @relation("Recv")
  requestsSent   FriendRequest[] @relation("Sent")
  friendshipsA   Friendship[]    @relation("A")
  friendshipsB   Friendship[]    @relation("B")
  organizedGames Game[]          @relation("OrganizerGames")
  participations Participation[]
  gameRoles      GameRole[]
  positions      UserPosition[]
  sports         UserSport[]
}

model Field {
  id           String          @id @default(cuid())
  name         String
  location     String
  description  String?
  price        Int             @default(0)
  rating       Float           @default(0)
  image        String?
  available    Boolean         @default(true)
  type         FieldType
  lat          Float?
  lng          Float?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  city         String?
  email        String?
  featuresJson Json?
  neighborhood String?
  phone        String?
  photos       String[]
  street       String?
  streetNumber String?
  favorites    FavoriteField[]
  games        Game[]
}

model Game {
  id           String          @id @default(cuid())
  fieldId      String
  /// Optional reference to a recurring series
  seriesId     String?
  start        DateTime
  duration     Int             @default(1)
  maxPlayers   Int
  isOpenToJoin Boolean         @default(true)
  // Visible only to organizer's friends and participants when true
  isFriendsOnly Boolean        @default(false)
  // When set, game becomes public automatically at this time
  friendsOnlyUntil DateTime?
  // Allow signups beyond capacity and finalize participants by lottery
  lotteryEnabled    Boolean   @default(false)
  // Exact datetime when the lottery should run (when enabled)
  lotteryAt        DateTime?
  // Include organizer in the lottery draw instead of confirming them immediately
  organizerInLottery Boolean  @default(false)
  // Set when the lottery has executed
  lotteryExecutedAt DateTime?
  description  String?
  // Optional custom location for games not tied to a mapped field
  customLat    Float?
  customLng    Float?
  customLocation String?
  organizerId  String
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  field        Field           @relation(fields: [fieldId], references: [id])
  organizer    User            @relation("OrganizerGames", fields: [organizerId], references: [id])
  /// Parent series relation (optional)
  series       GameSeries?     @relation(fields: [seriesId], references: [id])
  participants Participation[]
  roles        GameRole[]
  teams        Team[]
}

model Participation {
  id        String   @id @default(cuid())
  gameId    String
  userId    String
  teamId    String?
  status    ParticipationStatus @default(CONFIRMED)
  createdAt DateTime @default(now())
  game      Game     @relation(fields: [gameId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
  team      Team?    @relation(fields: [teamId], references: [id])

  @@unique([gameId, userId])
}

model Message {
  id        String   @id @default(cuid())
  roomId    String
  userId    String?
  text      String
  createdAt DateTime @default(now())
}

model FavoriteField {
  id      String @id @default(cuid())
  userId  String
  fieldId String
  field   Field  @relation(fields: [fieldId], references: [id])
  user    User   @relation(fields: [userId], references: [id])

  @@unique([userId, fieldId])
}

model Friendship {
  id        String   @id @default(cuid())
  userAId   String
  userBId   String
  createdAt DateTime @default(now())
  userA     User     @relation("A", fields: [userAId], references: [id])
  userB     User     @relation("B", fields: [userBId], references: [id])

  @@unique([userAId, userBId])
}

model FriendRequest {
  id          String              @id @default(cuid())
  requesterId String
  receiverId  String
  status      FriendRequestStatus @default(PENDING)
  createdAt   DateTime            @default(now())
  receiver    User                @relation("Recv", fields: [receiverId], references: [id])
  requester   User                @relation("Sent", fields: [requesterId], references: [id])

  @@unique([requesterId, receiverId])
}

model Sport {
  id        String      @id @default(cuid())
  name      String      @unique
  positions Position[]
  users     UserSport[]
}

model Position {
  id      String         @id @default(cuid())
  name    String
  sportId String
  sport   Sport          @relation(fields: [sportId], references: [id])
  users   UserPosition[]

  @@unique([sportId, name])
}

model UserSport {
  id      String @id @default(cuid())
  userId  String
  sportId String
  sport   Sport  @relation(fields: [sportId], references: [id])
  user    User   @relation(fields: [userId], references: [id])

  @@unique([userId, sportId])
}

model UserPosition {
  id         String   @id @default(cuid())
  userId     String
  positionId String
  position   Position @relation(fields: [positionId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@unique([userId, positionId])
}

model GameRole {
  id        String        @id @default(cuid())
  gameId    String
  userId    String
  role      GameRoleType  @default(MANAGER)
  createdAt DateTime      @default(now())
  game      Game          @relation(fields: [gameId], references: [id])
  user      User          @relation(fields: [userId], references: [id])

  @@unique([gameId, userId])
}

model Team {
  id        String   @id @default(cuid())
  gameId    String
  name      String
  color     String   // hex color
  createdAt DateTime @default(now())
  game      Game     @relation(fields: [gameId], references: [id])
  players   Participation[]

  @@index([gameId])
}

enum FieldType {
  OPEN
  CLOSED
}

enum FriendRequestStatus {
  PENDING
  DECLINED
}

enum ParticipationStatus {
  WAITLISTED
  CONFIRMED
  CANCELLED
  NOT_SELECTED
}

enum GameRoleType {
  ORGANIZER
  MANAGER
  MODERATOR
}

model GameSeries {
  id             String   @id @default(cuid())
  organizerId    String
  fieldId        String?
  fieldName      String
  fieldLocation  String
  price          Int      @default(0)
  maxPlayers     Int
  /// 0-6 (Sunday=0 per JS Date.getDay()) - only for WEEKLY
  dayOfWeek      Int?
  /// "HH:MM"
  time           String
  /// hours (can be fractional)
  duration       Float
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  /// Recurrence type: weekly auto vs. custom dates
  type           RecurrenceType @default(WEEKLY)

  games          Game[]
  subscribers    SeriesParticipant[]
}

model SeriesParticipant {
  id         String   @id @default(cuid())
  seriesId   String
  userId     String
  createdAt  DateTime @default(now())

  series     GameSeries @relation(fields: [seriesId], references: [id])
  user       User       @relation(fields: [userId], references: [id])

  @@unique([seriesId, userId])
}

enum RecurrenceType {
  WEEKLY
  CUSTOM
}
